<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute cloth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				color: white;
				font-family: Arial, sans-serif;
				background-color: rgba(0,0,0,0.5);
				padding: 5px;
				z-index: 100;
			}
			#info a { color: #4cc9f0; }
		</style>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - compute cloth<br />
			Interactive cloth simulation
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { Fn, If, Return, instancedArray, instanceIndex, uniform, select, attribute, uint, Loop, float, transformNormalToView, cross, triNoise3D, time } from 'three/tsl';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

			let renderer, scene, camera, controls;
			let lastCameraPosition = new THREE.Vector3();
			let cameraMovement = new THREE.Vector3();

			const clothWidth = 1;
			const clothHeight = 1;
			const clothNumSegmentsX = 30;
			const clothNumSegmentsY = 30;

			let vertexPositionBuffer, vertexForceBuffer, vertexParamsBuffer;
			let springVertexIdBuffer, springRestLengthBuffer, springForceBuffer;
			let springListBuffer;
			let computeSpringForces, computeVertexForces;
			let dampeningUniform, stiffnessUniform, windUniform, cameraMovementUniform;
			let vertexWireframeObject, springWireframeObject;
			let clothMesh, clothMaterial;
			let timeSinceLastStep = 0;
			let timestamp = 0;
			const verletVertices = [];
			const verletSprings = [];
			const verletVertexColumns = [];

			const clock = new THREE.Clock();

			const params = {
				wireframe: false,
				wind: 1.0,
				cameraInfluence: 0.5 // nowy parametr - siła wpływu kamery
			};

			init();

			async function init() {
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1;
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( -1.6, -0.1, -1.6 );
				lastCameraPosition.copy(camera.position);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 3;
				controls.target.set( 0, -0.1, 0 );
				controls.update();

				const rgbeLoader = new RGBELoader().setPath( 'textures/equirectangular/' );
				const hdrTexture = await rgbeLoader.loadAsync( 'royal_esplanade_1k.hdr' );
				hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
				scene.background = hdrTexture;
				scene.backgroundBlurriness = 0.5;
				scene.environment = hdrTexture;

				setupCloth();

				const gui = new GUI();
				gui.add( stiffnessUniform, 'value', 0.1, 0.5, 0.01 ).name( 'stiffness' );
				gui.add( params, 'wireframe' );
				gui.add( params, 'wind', 0, 5, 0.1 );
				gui.add( params, 'cameraInfluence', 0, 2, 0.1 ).name('camera influence');
				
				const materialFolder = gui.addFolder( 'material' );
				materialFolder.addColor( clothMaterial, 'color' );
				materialFolder.add( clothMaterial, 'roughness', 0.0, 1, 0.01 );
				materialFolder.add( clothMaterial, 'sheen', 0.0, 1, 0.01 );
				materialFolder.add( clothMaterial, 'sheenRoughness', 0.0, 1, 0.01 );
				materialFolder.addColor( clothMaterial, 'sheenColor' );

				window.addEventListener( 'resize', onWindowResize );
				renderer.setAnimationLoop( render );
			}

			// ... (pozostałe funkcje setupVerletGeometry, setupVerletVertexBuffers, 
			// setupVerletSpringBuffers pozostają bez zmian)

			function setupUniforms() {
				dampeningUniform = uniform( 0.99 );
				stiffnessUniform = uniform( 0.2 );
				windUniform = uniform( 1.0 );
				cameraMovementUniform = uniform( new THREE.Vector3(0, 0, 0) );
			}

			function setupComputeShaders() {
				const vertexCount = verletVertices.length;
				const springCount = verletSprings.length;

				computeSpringForces = Fn( () => {
					If( instanceIndex.greaterThanEqual( uint( springCount ) ), () => {
						Return();
					} );

					const vertexIds = springVertexIdBuffer.element( instanceIndex );
					const restLength = springRestLengthBuffer.element( instanceIndex );

					const vertex0Position = vertexPositionBuffer.element( vertexIds.x );
					const vertex1Position = vertexPositionBuffer.element( vertexIds.y );

					const delta = vertex1Position.sub( vertex0Position ).toVar();
					const dist = delta.length().max( 0.000001 ).toVar();
					const force = dist.sub( restLength ).mul( stiffnessUniform ).mul( delta ).mul( 0.5 ).div( dist );
					springForceBuffer.element( instanceIndex ).assign( force );
				} )().compute( springCount );

				computeVertexForces = Fn( () => {
					If( instanceIndex.greaterThanEqual( uint( vertexCount ) ), () => {
						Return();
					} );

					const params = vertexParamsBuffer.element( instanceIndex ).toVar();
					const isFixed = params.x;
					const springCount = params.y;
					const springPointer = params.z;

					If( isFixed, () => {
						Return();
					} );

					const position = vertexPositionBuffer.element( instanceIndex ).toVar( 'vertexPosition' );
					const force = vertexForceBuffer.element( instanceIndex ).toVar( 'vertexForce' );

					force.mulAssign( dampeningUniform );

					const ptrStart = springPointer.toVar( 'ptrStart' );
					const ptrEnd = ptrStart.add( springCount ).toVar( 'ptrEnd' );

					Loop( { start: ptrStart, end: ptrEnd, type: 'uint', condition: '<' }, ( { i } ) => {
						const springId = springListBuffer.element( i ).toVar( 'springId' );
						const springForce = springForceBuffer.element( springId );
						const springVertexIds = springVertexIdBuffer.element( springId );
						const factor = select( springVertexIds.x.equal( instanceIndex ), 1.0, -1.0 );
						force.addAssign( springForce.mul( factor ) );
					} );

					// gravity
					force.y.subAssign( 0.00005 );

					// wind
					const noise = triNoise3D( position, 1, time ).sub( 0.2 ).mul( 0.0001 );
					const windForce = noise.mul( windUniform );
					force.z.subAssign( windForce );

					// camera movement influence
					force.addAssign( cameraMovementUniform.mul(params.cameraInfluence * 0.01) );

					vertexForceBuffer.element( instanceIndex ).assign( force );
					vertexPositionBuffer.element( instanceIndex ).addAssign( force );
				} )().compute( vertexCount );
			}

			// ... (pozostałe funkcje setupWireframe, setupClothMesh, setupCloth pozostają bez zmian)

			function updateCameraMovement() {
				cameraMovement.subVectors(camera.position, lastCameraPosition);
				cameraMovementUniform.value.copy(cameraMovement);
				lastCameraPosition.copy(camera.position);
			}

			async function render() {
				updateCameraMovement(); // Aktualizuj wektor ruchu kamery
				
				clothMesh.visible = ! params.wireframe;
				vertexWireframeObject.visible = params.wireframe;
				springWireframeObject.visible = params.wireframe;

				const deltaTime = Math.min( clock.getDelta(), 1 / 60 );
				const stepsPerSecond = 360;
				const timePerStep = 1 / stepsPerSecond;

				timeSinceLastStep += deltaTime;

				while ( timeSinceLastStep >= timePerStep ) {
					timestamp += timePerStep;
					timeSinceLastStep -= timePerStep;
					await renderer.computeAsync( computeSpringForces );
					await renderer.computeAsync( computeVertexForces );
				}

				await renderer.renderAsync( scene, camera );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
		</script>
	</body>
</html>
