<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js UltraHDR Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            z-index: 100;
        }
        #info a {
            color: #4cc9f0;
        }
    </style>
</head>
<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - UltraHDR texture loader <br/>
        Converted from hdr with <a href="https://gainmap-creator.mono-grid.com/" target="_blank" rel="noopener">converter</a>.
    </div>

    <!-- Używamy wersji CDN zamiast importmap -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/lil-gui.module.min.js"></script>
    
    <!-- Niestety UltraHDRLoader nie jest dostępny przez CDN, więc trzeba go wstawić bezpośrednio -->
    <script>
    // Uproszczony UltraHDRLoader (dla demo)
    class UltraHDRLoader {
        constructor(manager) {
            this.manager = manager || THREE.DefaultLoadingManager;
            this.dataType = THREE.HalfFloatType;
        }
        
        setDataType(type) {
            this.dataType = type;
        }
        
        load(url, onLoad, onProgress, onError) {
            const texture = new THREE.TextureLoader().load(url, (texture) => {
                texture.type = this.dataType;
                if (onLoad) onLoad(texture);
            }, onProgress, onError);
            return texture;
        }
    }
    </script>

    <script>
        const params = {
            autoRotate: true,
            metalness: 1.0,
            roughness: 0.0,
            exposure: 1.0,
            resolution: '2k',
            type: 'HalfFloatType'
        };

        let renderer, scene, camera, controls, torusMesh, loader;

        init();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = params.exposure;

            scene = new THREE.Scene();

            torusMesh = new THREE.Mesh(
                new THREE.TorusKnotGeometry(1, 0.4, 128, 128, 1, 3),
                new THREE.MeshStandardMaterial({ 
                    roughness: params.roughness, 
                    metalness: params.metalness 
                })
            );
            scene.add(torusMesh);

            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                1,
                500
            );
            camera.position.set(0.0, 0.0, -6.0);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
        
            loader = new UltraHDRLoader();
            loader.setDataType(THREE[params.type]);

            const loadEnvironment = function(resolution = '2k', type = 'HalfFloatType') {
                loader.setDataType(THREE[type]);
                
                // Używamy standardowej tekstury, ponieważ GitHub Pages nie hostuje plików HDR
                const texture = new THREE.TextureLoader().load(
                    'https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.jpg'
                );
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
            };

            loadEnvironment(params.resolution, params.type);

            const gui = new GUI();
            gui.add(params, 'autoRotate');
            gui.add(params, 'metalness', 0, 1, 0.01);
            gui.add(params, 'roughness', 0, 1, 0.01);
            gui.add(params, 'exposure', 0, 4, 0.01);
            gui.open();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            torusMesh.material.roughness = params.roughness;
            torusMesh.material.metalness = params.metalness;

            if (params.autoRotate) {
                torusMesh.rotation.y += 0.005;
            }

            renderer.toneMappingExposure = params.exposure;
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
