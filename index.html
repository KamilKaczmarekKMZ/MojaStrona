<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistyczna twarz z cząstek</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Parametry twarzy
        const face = {
            width: 300,
            height: 400,
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            jawWidth: 220,
            foreheadWidth: 250,
            chinY: () => face.centerY + face.height * 0.4
        };

        // Funkcja sprawdzająca przynależność do części twarzy
        function isInFace(x, y) {
            // Kontur twarzy (bardziej anatomiczny)
            const inHead = (
                y > face.centerY - face.height * 0.4 && // Czoło
                y < face.chinY() && // Broda
                Math.abs(x - face.centerX) < (
                    (y < face.centerY) 
                        ? face.foreheadWidth * 0.5 * (1 - (face.centerY - y) / (face.height * 0.4)) // Zwężanie ku górze
                        : face.jawWidth * 0.5 * (1 - (y - face.centerY) / (face.height * 0.4)) // Zwężanie ku dołowi
            );

            // Oczy (migdałowy kształt)
            const eyeWidth = face.width * 0.12;
            const eyeHeight = face.width * 0.07;
            const leftEyeX = face.centerX - face.width * 0.18;
            const rightEyeX = face.centerX + face.width * 0.18;
            const eyesY = face.centerY - face.height * 0.1;

            const inLeftEye = (
                Math.pow((x - leftEyeX) / eyeWidth, 2) + 
                Math.pow((y - eyesY) / eyeHeight, 2) < 1
            );
            const inRightEye = (
                Math.pow((x - rightEyeX) / eyeWidth, 2) + 
                Math.pow((y - eyesY) / eyeHeight, 2) < 1
            );

            // Nos (trójkąt)
            const noseBottomY = face.centerY + face.height * 0.1;
            const inNose = (
                y > face.centerY && 
                y < noseBottomY && 
                Math.abs(x - face.centerX) < face.width * 0.1 * (1 - (y - face.centerY) / (noseBottomY - face.centerY))
            );

            // Usta (krzywa Béziera)
            const mouthWidth = face.width * 0.3;
            const mouthY = face.centerY + face.height * 0.25;
            const mouthCurve = (x) => {
                const t = (x - (face.centerX - mouthWidth/2)) / mouthWidth;
                if (t < 0 || t > 1) return Infinity;
                return mouthY + 15 * Math.sin(t * Math.PI);
            };
            const inMouth = (
                x > face.centerX - mouthWidth/2 && 
                x < face.centerX + mouthWidth/2 && 
                y > mouthY - 10 && 
                y < mouthCurve(x)
            );

            return inHead && !inLeftEye && !inRightEye && !inNose && !inMouth;
        }

        // Generowanie cząstek
        const particles = [];
        const particleCount = 3000;

        for (let i = 0; i < particleCount; i++) {
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (!isInFace(x, y));
            
            particles.push({
                x, y,
                baseX: x,
                baseY: y,
                size: Math.random() * 2 + 1,
                density: Math.random() * 10 + 5,
                color: `hsl(${Math.random() * 30 + 15}, 70%, ${Math.random() * 20 + 60}%)` // Odcienie skóry
            });
        }

        // Interakcja z myszą
        const mouse = { x: null, y: null, radius: 120 };
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });

        // Animacja
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(p => {
                // Oddziaływanie myszy
                const dx = mouse.x - p.x;
                const dy = mouse.y - p.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < mouse.radius) {
                    const force = (mouse.radius - distance) / mouse.radius;
                    const angle = Math.atan2(dy, dx);
                    p.x -= Math.cos(angle) * force * p.density * 0.5;
                    p.y -= Math.sin(angle) * force * p.density * 0.5;
                } else {
                    // Powrót do pozycji
                    p.x += (p.baseX - p.x) * 0.05;
                    p.y += (p.baseY - p.y) * 0.05;
                }
                
                // Rysowanie
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            requestAnimationFrame(animate);
        }

        animate();

        // Responsywność
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            face.centerX = canvas.width / 2;
            face.centerY = canvas.height / 2;
        });
    </script>
</body>
</html>
